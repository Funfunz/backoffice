{"version":3,"sources":["views/playground/index.tsx","hooks/useEntry.ts"],"names":["Playground","entities","useEntities","entity","useEntity","useEntry","id","entry","setEntry","saveEntry","newEntry","setNewEntry","addEntry","JSON","stringify","mapFieldComponents","map","field","index","props","label","onChange","event","target","name","value","onClick","memo","filterOrPk","useState","fetchedEntry","setFetchedEntry","modifiedEntry","setModifiedEntry","loading","setLoading","error","setError","filter","useMemo","getPk","oldArgs","setNewArgs","hasNewArgs","useCallback","getName","entryEquals","useEffect","getEntryData","then","data","filterMatch","catch","saveEntryData","entryDiff"],"mappings":"mLAMMA,EAAiB,WACrB,IAAMC,EAAWC,cACXC,EAASC,YAAU,YAFE,EAGYC,YAASF,EAAQ,CAAEG,GAAI,IAAtDC,EAHmB,EAGnBA,MAAOC,EAHY,EAGZA,SAAUC,EAHE,EAGFA,UAHE,EAI6CJ,YAASF,GAAlEO,EAJY,EAInBH,MAA2BI,EAJR,EAIFH,SAAkCI,EAJhC,EAIqBH,UAEhD,OACE,gCACE,0CACA,8BACGI,KAAKC,UAAUb,EAAU,KAAM,KAElC,wCACA,8BACGY,KAAKC,UAAUX,EAAQ,KAAM,KAEhC,4CACA,8BACGU,KAAKC,UAAUP,EAAO,KAAM,KAE/B,8CACCQ,YAAmBZ,GAAQa,KAAI,SAACC,EAAOC,GAAR,OAG9B,cAFA,CAEA,iBACE,gCAAQD,EAAME,MAAMC,QAAc,uBAClC,iDACMH,EAAME,OADZ,IAEEE,SAAU,SAACC,GAAD,OAAWd,GAAS,SAACD,GAAD,mBAAC,eAAeA,GAAhB,kBAAwBe,EAAMC,OAAOC,KAAOF,EAAMC,OAAOE,YACvFA,MAAOlB,EAAMU,EAAME,MAAMK,OAAmB,QALtCN,MASZ,wBAAQQ,QAASjB,EAAjB,kBACA,2CACCM,YAAmBZ,GAAQa,KAAI,SAACC,EAAOC,GAAR,OAG9B,cAFA,CAEA,iBACE,gCAAQD,EAAME,MAAMC,QAAc,uBAClC,iDACMH,EAAME,OADZ,IAEEE,SAAU,SAACC,GAAD,OAAWX,GAAY,SAACJ,GAAD,mBAAC,eAAeG,GAAhB,kBAA2BY,EAAMC,OAAOC,KAAOF,EAAMC,OAAOE,YAC7FA,MAAOf,EAASO,EAAME,MAAMK,OAAmB,QALzCN,MASZ,wBAAQQ,QAASd,EAAjB,qBAKSe,yBAAK3B,I,qGCtCb,SAASK,EAASF,EAAiByB,GAAoD,IAAD,EAEnDC,mBAAqB,IAF8B,mBAEpFC,EAFoF,KAEtEC,EAFsE,OAGjDF,mBAAqB,IAH4B,mBAGpFG,EAHoF,KAGrEC,EAHqE,OAK7DJ,oBAAS,GALoD,mBAKpFK,EALoF,KAK3EC,EAL2E,OAMjEN,oBAAS,GANwD,mBAMpFO,EANoF,KAM7EC,EAN6E,KAQrFC,EAASC,mBAAQ,WACrB,MAA8B,kBAAfX,GAAiD,kBAAfA,EAA1C,sBACAzB,QADA,IACAA,OADA,EACAA,EAAQqC,QAAoBZ,GAC/BA,IACH,CAACA,EAAYzB,IAZ2E,EAc7D0B,mBAAgD,IAda,mBAcpFY,EAdoF,KAc3EC,EAd2E,KAgBrFC,EAAaC,uBAAY,WAC7B,QACQ,OAANzC,QAAM,IAANA,OAAA,EAAAA,EAAQ0C,aAAcJ,EAAQtC,SAC7B2C,YAAYR,EAAQG,EAAQH,WAE7BI,EAAW,CAAEvC,OAAM,OAAEA,QAAF,IAAEA,OAAF,EAAEA,EAAQ0C,UAAWP,YACjC,KAGR,CAACnC,EAAQsC,EAASH,IAErBS,qBAAU,YAENJ,KACCT,GAAYE,GACZU,YAAYhB,EAAcQ,KAC3BnC,IAEAgC,GAAW,GACXa,YAAa7C,EAAQmC,GAAQW,MAAK,SAACC,GACjCf,GAAW,GACPe,GAAQC,YAAYD,EAAMZ,IAC5BP,EAAgBmB,GAChBjB,EAAiBiB,GACjBb,GAAS,IAETA,GAAS,MAEVe,OAAM,WACPjB,GAAW,GACXE,GAAS,SAGZ,CAAClC,EAAQ+B,EAASI,EAAQF,EAAON,EAAca,IAElD,IAAMlC,EAAYmC,uBAAY,WAC5B,OAAOS,YACLlD,EACAmD,YAAUxB,EAAcE,GACxBM,KAED,CAACnC,EAAQmC,EAAQN,EAAeF,IAEnC,MAAO,CACLvB,MAAOyB,EACPxB,SAAUyB,EACVxB,YACA2B","file":"static/js/10.b843f404.chunk.js","sourcesContent":["import React, { FC, memo } from 'react'\nimport { useEntities } from 'hooks/useEntities'\nimport { useEntity } from 'hooks/useEntity'\nimport { useEntry } from 'hooks/useEntry'\nimport { mapFieldComponents } from 'utils/fields'\n\nconst Playground: FC = () => {\n  const entities = useEntities()\n  const entity = useEntity('products')\n  const { entry, setEntry, saveEntry } = useEntry(entity, { id: 1 })\n  const { entry: newEntry, setEntry: setNewEntry, saveEntry: addEntry } = useEntry(entity)\n\n  return (\n    <div>\n      <h1>Entities</h1>\n      <pre>\n        {JSON.stringify(entities, null, 4)}\n      </pre>\n      <h1>Entity</h1>\n      <pre>\n        {JSON.stringify(entity, null, 4)}\n      </pre>\n      <h1>User entry</h1>\n      <pre>\n        {JSON.stringify(entry, null, 4)}\n      </pre>\n      <h1>Update entry</h1>\n      {mapFieldComponents(entity).map((field, index) =>\n        // match `field.component` to correct React component\n        // pass `field.props` to that component\n        <div key={index}>\n          <label>{field.props.label}</label><br />\n          <input \n            {...field.props} \n            onChange={(event) => setEntry((entry) => ({...entry, [event.target.name]: event.target.value}))} \n            value={entry[field.props.name] as string || ''} />\n        </div>\n        \n      )}\n      <button onClick={saveEntry}>Save</button>\n      <h1>Add entry</h1>\n      {mapFieldComponents(entity).map((field, index) =>\n        // match `field.component` to correct React component\n        // pass `field.props` to that component\n        <div key={index}>\n          <label>{field.props.label}</label><br />\n          <input \n            {...field.props} \n            onChange={(event) => setNewEntry((entry) => ({...newEntry, [event.target.name]: event.target.value}))} \n            value={newEntry[field.props.name] as string || ''} />\n        </div>\n        \n      )}\n      <button onClick={addEntry}>Add</button>\n    </div>\n  )\n}\n\nexport default memo(Playground)","import { useCallback, useEffect, useMemo, useState } from 'react'\nimport Entity from '../services/entity'\nimport { \n  entryDiff,\n  entryEquals,\n  filterMatch,\n  getEntryData,\n  IEntryData,\n  IFilter,\n  saveEntryData,\n} from '../services/entry'\n\nexport interface IUseEntry {\n  entry: IEntryData,\n  setEntry: React.Dispatch<React.SetStateAction<IEntryData>>,\n  saveEntry: () => Promise<void>,\n  error: boolean\n}\n\n/* Get entry data based on a filter */\nexport function useEntry(entity?: Entity, filterOrPk?: IFilter | string | number): IUseEntry {\n\n  const [fetchedEntry, setFetchedEntry] = useState<IEntryData>({})\n  const [modifiedEntry, setModifiedEntry] = useState<IEntryData>({})\n\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState(false)\n  \n  const filter = useMemo(() => {\n    return (typeof filterOrPk === 'string' || typeof filterOrPk === 'number')\n      ? { [entity?.getPk() as string]: filterOrPk }\n      : filterOrPk\n  }, [filterOrPk, entity])\n\n  const [oldArgs, setNewArgs] = useState<{ entity?: string, filter?: IFilter }>({})\n\n  const hasNewArgs = useCallback(() => {\n    if (\n      entity?.getName() !== oldArgs.entity ||\n      !entryEquals(filter, oldArgs.filter)\n    ) {\n      setNewArgs({ entity: entity?.getName(), filter })\n      return true\n    }\n    return false\n  }, [entity, oldArgs, filter])\n\n  useEffect(() => {\n    if (\n      hasNewArgs() && \n      !loading && !error &&\n      !entryEquals(fetchedEntry, filter) &&\n      entity\n    ) {\n      setLoading(true)\n      getEntryData(entity, filter).then((data) => {\n        setLoading(false)\n        if (data && filterMatch(data, filter as IFilter)) {\n          setFetchedEntry(data)\n          setModifiedEntry(data)\n          setError(false)\n        } else {\n          setError(true)\n        }\n      }).catch(() => {\n        setLoading(false)\n        setError(true)\n      })\n    } \n  }, [entity, loading, filter, error, fetchedEntry, hasNewArgs])\n\n  const saveEntry = useCallback(() => {\n    return saveEntryData(\n      entity as Entity,\n      entryDiff(fetchedEntry, modifiedEntry),\n      filter,\n    )\n  }, [entity, filter, modifiedEntry, fetchedEntry])\n\n  return {\n    entry: modifiedEntry,\n    setEntry: setModifiedEntry,\n    saveEntry,\n    error,\n  }\n}"],"sourceRoot":""}